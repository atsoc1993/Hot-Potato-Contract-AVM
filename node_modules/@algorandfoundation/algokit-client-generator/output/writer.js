'use strict';

const IncIndent = Symbol('Increase Indent');
const DecIndent = Symbol('Decrease Indent');
const DecIndentAndCloseBlock = Symbol('Decrease Indent and write a closing brace');
const NewLineMode = Symbol('New Line Mode');
const RestoreLineMode = Symbol('Restore Line Mode');
const PropertyDelimiter = Symbol('Property Delimiter');
const InlineMode = Symbol('Inline Mode');
const NewLine = Symbol('New Line');
function writeDocumentPartsToStream(document, stream, options = {}) {
    const writer = {
        _last: '',
        write(val) {
            this._last = val;
            stream.write(val);
        },
        get last() {
            return this._last;
        },
    };
    writeDocumentPartsTo(document, options, writer);
}
function writeDocumentPartsToString(document, options = {}) {
    const writer = {
        result: [],
        _last: '',
        write(val) {
            this._last = val;
            this.result.push(val);
        },
        get last() {
            return this._last;
        },
        toString() {
            return this.result.join('');
        },
    };
    writeDocumentPartsTo(document, options, writer);
    return writer.toString();
}
function* inline(...parts) {
    yield InlineMode;
    for (const part of parts) {
        if (typeof part === 'string' || typeof part === 'symbol')
            yield part;
        else
            yield* part;
    }
    yield RestoreLineMode;
}
function* indent(...parts) {
    yield IncIndent;
    for (const part of parts) {
        if (typeof part === 'string' || typeof part === 'symbol')
            yield part;
        else
            yield* part;
    }
    yield DecIndent;
}
function* jsDoc(docs) {
    yield `/**`;
    if (typeof docs === 'string' || Array.isArray(docs)) {
        const description = typeof docs === 'string' ? [docs] : docs;
        for (const line of description) {
            yield ` * ${line}`;
        }
    }
    else {
        const description = typeof docs.description === 'string' ? [docs.description] : docs.description;
        for (const line of description) {
            yield ` * ${line}`;
        }
        if (docs.abiDescription) {
            yield ' *';
            yield ` * ${docs.abiDescription}`;
        }
        if (docs.params || docs.returns) {
            yield ' *';
        }
        for (const [paramName, paramDesc] of Object.entries(docs.params ?? {})) {
            yield ` * @param ${paramName} ${paramDesc}`;
        }
        if (docs.returns)
            yield ` * @returns ${docs.returns}`;
    }
    yield ' */';
}
function writeDocumentPartsTo(document, { indent = '  ', ...options }, writer) {
    if (options.header)
        writer.write(`${options.header}\n`);
    if (options.disableEslint)
        writer.write('/* eslint-disable */\n');
    const lineModes = [NewLineMode];
    const currentLineMode = () => lineModes.at(-1) ?? NewLineMode;
    let curIndent = '';
    for (const part of document) {
        switch (part) {
            case IncIndent:
                curIndent += indent;
                break;
            case DecIndent:
                curIndent = curIndent.slice(0, -indent.length);
                break;
            case DecIndentAndCloseBlock:
                curIndent = curIndent.slice(0, -indent.length);
                writer.write(`${curIndent}}\n`);
                break;
            case NewLineMode:
                lineModes.push(NewLineMode);
                if (writer.last.slice(-1)[0] !== '\n') {
                    writer.write('\n');
                }
                break;
            case InlineMode:
                lineModes.push(InlineMode);
                break;
            case RestoreLineMode:
                lineModes.pop();
                if (currentLineMode() === NewLineMode && writer.last.slice(-1)[0] !== '\n') {
                    writer.write('\n');
                }
                break;
            case PropertyDelimiter:
                if (currentLineMode() === NewLineMode) {
                    writer.write('\n');
                }
                else {
                    writer.write(', ');
                }
                break;
            case NewLine:
                writer.write('\n');
                break;
            default:
                // Multi-line
                if (part.includes('\n') || part.includes('\r')) {
                    if (writer.last.slice(-1)[0] !== '\n')
                        writer.write('\n');
                    const normalisedLineEndings = part.replaceAll(/\r\n/g, '\n').replaceAll(/\r/g, '\n').replace(/^\n/, '').trimEnd();
                    const lines = normalisedLineEndings.split('\n');
                    const baseIndent = lines[0].match(/^\s+/)?.[0] ?? '';
                    for (const line of lines) {
                        writer.write(curIndent + line.replace(new RegExp(`^${baseIndent}`, ''), '').trimEnd());
                        writer.write('\n');
                    }
                }
                else {
                    if (writer.last.slice(-1)[0] === '\n')
                        writer.write(curIndent);
                    writer.write(part);
                }
                if (currentLineMode() === NewLineMode)
                    writer.write('\n');
                break;
        }
    }
}

exports.DecIndent = DecIndent;
exports.DecIndentAndCloseBlock = DecIndentAndCloseBlock;
exports.IncIndent = IncIndent;
exports.InlineMode = InlineMode;
exports.NewLine = NewLine;
exports.NewLineMode = NewLineMode;
exports.PropertyDelimiter = PropertyDelimiter;
exports.RestoreLineMode = RestoreLineMode;
exports.indent = indent;
exports.inline = inline;
exports.jsDoc = jsDoc;
exports.writeDocumentPartsToStream = writeDocumentPartsToStream;
exports.writeDocumentPartsToString = writeDocumentPartsToString;
//# sourceMappingURL=writer.js.map
