'use strict';

var writer = require('../output/writer.js');
var getCallConfigSummary = require('./helpers/get-call-config-summary.js');
var deployTypes = require('./deploy-types.js');
var algosdk = require('algosdk');

function* callComposerType(ctx) {
    const { name, callConfig, app } = ctx;
    yield `export type ${name}Composer<TReturns extends [...any[]] = []> = {`;
    yield writer.IncIndent;
    yield* callComposerTypeNoops(ctx);
    yield* callComposerOperationMethodType(ctx, `Deletes an existing instance of the ${app.name} smart contract`, callConfig.deleteMethods, 'delete');
    yield* callComposerOperationMethodType(ctx, `Opts the user into an existing instance of the ${app.name} smart contract`, callConfig.optInMethods, 'optIn');
    yield* callComposerOperationMethodType(ctx, `Makes a close out call to an existing instance of the ${app.name} smart contract`, callConfig.closeOutMethods, 'closeOut');
    yield* callComposerOperationMethodType(ctx, `Updates an existing instance of the ${app.name} smart contract`, callConfig.updateMethods, 'update');
    yield* callComposerTypeClearState(ctx);
    yield* writer.jsDoc({
        description: 'Adds a transaction to the composer',
        params: {
            txn: 'A transaction to add to the transaction group',
            signer: 'The optional signer to use when signing this transaction.',
        },
    });
    yield `addTransaction(txn: Transaction, signer?: TransactionSigner): ${name}Composer<TReturns>`;
    yield* writer.jsDoc({
        description: 'Returns the underlying AtomicTransactionComposer instance',
    });
    yield `composer(): Promise<TransactionComposer>`;
    yield* writer.jsDoc({
        description: 'Simulates the transaction group and returns the result',
    });
    yield `simulate(): Promise<${name}ComposerResults<TReturns> & { simulateResponse: SimulateResponse }>`;
    yield `simulate(options: SkipSignaturesSimulateOptions): Promise<${name}ComposerResults<TReturns> & { simulateResponse: SimulateResponse }>`;
    yield `simulate(options: RawSimulateOptions): Promise<${name}ComposerResults<TReturns> & { simulateResponse: SimulateResponse }>`;
    yield* writer.jsDoc({
        description: 'Sends the transaction group to the network and returns the results',
    });
    yield `send(params?: SendParams): Promise<${name}ComposerResults<TReturns>>`;
    yield writer.DecIndentAndCloseBlock;
    yield `
  export type ${name}ComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns
  }>
  `;
}
function* callComposerTypeClearState({ app, name }) {
    yield* writer.jsDoc({
        description: `Makes a clear_state call to an existing instance of the ${app.name} smart contract.`,
        params: {
            args: `The arguments for the bare call`,
        },
        returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,
    });
    yield `clearState(params?: AppClientBareCallParams): ${name}Composer<[...TReturns, undefined]>`;
    yield writer.NewLine;
}
function* callComposerTypeNoops({ app, name, callConfig, methodSignatureToUniqueName, sanitizer }) {
    for (const method of app.methods) {
        const methodSig = new algosdk.ABIMethod(method).getSignature();
        const methodSigSafe = sanitizer.makeSafeStringTypeLiteral(methodSig);
        const methodName = sanitizer.makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSig]);
        // Skip methods which don't support a no_op call config
        if (!callConfig.callMethods.includes(methodSig))
            continue;
        yield* writer.jsDoc({
            description: `Calls the ${new algosdk.ABIMethod(method).getSignature()} ABI method.`,
            abiDescription: method.desc,
            params: {
                args: `The arguments for the contract call`,
                params: `Any additional parameters for the call`,
            },
            returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,
        });
        yield `${methodName}(params?: CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']>): ${name}Composer<[...TReturns, ${name}Returns['${methodSigSafe}'] | undefined]>`;
        yield writer.NewLine;
    }
}
function* callComposerOperationMethodType({ app, methodSignatureToUniqueName, name, sanitizer }, description, methods, verb, includeCompilation) {
    if (methods.length) {
        yield* writer.jsDoc(`Gets available ${verb} methods`);
        yield `readonly ${verb}: {`;
        yield writer.IncIndent;
        for (const methodSig of methods) {
            const onComplete = verb === 'create' ? deployTypes.getCreateOnCompleteOptions(methodSig, app) : undefined;
            if (methodSig === getCallConfigSummary.BARE_CALL) {
                yield* writer.jsDoc({
                    description: `${description} using a bare call.`,
                    params: {
                        args: `The arguments for the bare call`,
                    },
                    returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,
                });
                yield `bare(params${onComplete?.isOptional !== false ? '?' : ''}: AppClientBareCallParams ${''}): ${name}Composer<[...TReturns, undefined]>`;
            }
            else {
                const uniqueName = methodSignatureToUniqueName[methodSig];
                yield* writer.jsDoc({
                    description: `${description} using the ${methodSig} ABI method.`,
                    params: {
                        args: `The arguments for the smart contract call`,
                        params: `Any additional parameters for the call`,
                    },
                    returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,
                });
                const methodSigSafe = sanitizer.makeSafeStringTypeLiteral(methodSig);
                yield `${sanitizer.makeSafeMethodIdentifier(uniqueName)}(params${onComplete?.isOptional !== false ? '?' : ''}: CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']>${''}${onComplete?.type ? ` & ${onComplete.type}` : ''}): ${name}Composer<[...TReturns, ${name}Returns['${methodSigSafe}'] | undefined]>`;
            }
        }
        yield writer.DecIndentAndCloseBlock;
        yield writer.NewLine;
    }
}

exports.callComposerType = callComposerType;
//# sourceMappingURL=call-composer-types.js.map
