'use strict';

var writer = require('../output/writer.js');
var getCallConfigSummary = require('./helpers/get-call-config-summary.js');
var deployTypes = require('./deploy-types.js');
var algosdk = require('algosdk');

function* paramsFactory(ctx) {
    yield* writer.jsDoc(`Exposes methods for constructing \`AppClient\` params objects for ABI calls to the ${ctx.name} smart contract`);
    yield `export abstract class ${ctx.name}ParamsFactory {`;
    yield writer.IncIndent;
    yield* opMethods(ctx);
    for (const method of ctx.app.methods) {
        yield* callFactoryMethod(ctx, method);
    }
    yield writer.DecIndent;
    yield '}';
}
function* opMethods(ctx) {
    const { app, callConfig } = ctx;
    yield* operationMethod(ctx, `Constructs create ABI call params for the ${app.name} smart contract`, callConfig.createMethods, 'create', true);
    yield* operationMethod(ctx, `Constructs update ABI call params for the ${app.name} smart contract`, callConfig.updateMethods, 'update', true);
    yield* operationMethod(ctx, `Constructs delete ABI call params for the ${app.name} smart contract`, callConfig.deleteMethods, 'delete');
    yield* operationMethod(ctx, `Constructs opt-in ABI call params for the ${app.name} smart contract`, callConfig.optInMethods, 'optIn');
    yield* operationMethod(ctx, `Constructs close out ABI call params for the ${app.name} smart contract`, callConfig.closeOutMethods, 'closeOut');
}
function* operationMethod(ctx, description, methods, verb, includeCompilation) {
    const { app, methodSignatureToUniqueName, sanitizer, name } = ctx;
    if (methods.length > 0 && methods.some((m) => m !== getCallConfigSummary.BARE_CALL)) {
        yield* writer.jsDoc(`Gets available ${verb} ABI call param factories`);
        yield `static get ${verb}() {`;
        yield writer.IncIndent;
        yield `return {`;
        yield writer.IncIndent;
        if (['create', 'update', 'delete'].includes(verb)) {
            yield `_resolveByMethod<TParams extends ${ctx.name}${verb[0].toUpperCase()}${verb.substring(1)}CallParams & {method: string}>(params: TParams) {`;
            yield writer.IncIndent;
            yield `switch(params.method) {`;
            yield writer.IncIndent;
            for (const methodSig of methods) {
                if (methodSig === getCallConfigSummary.BARE_CALL)
                    continue;
                const uniqueName = methodSignatureToUniqueName[methodSig];
                if (uniqueName !== methodSig) {
                    yield `case '${sanitizer.makeSafeStringTypeLiteral(uniqueName)}':`;
                }
                yield `case '${sanitizer.makeSafeStringTypeLiteral(methodSig)}':`;
                yield* writer.indent(`return ${ctx.name}ParamsFactory.${verb}${sanitizer.getSafeMemberAccessor(sanitizer.makeSafeMethodIdentifier(uniqueName))}(params)`);
            }
            yield writer.DecIndentAndCloseBlock;
            // Ordinarily we'd pop in the params.method value, but we can't here since it knows at compile time the type of params.method is never
            yield `throw new Error(\`Unknown ' + verb + ' method\`)`;
            yield writer.DecIndent;
            yield '},';
            yield writer.NewLine;
        }
        for (const methodSig of methods) {
            const onComplete = verb === 'create' ? deployTypes.getCreateOnCompleteOptions(methodSig, app) : undefined;
            if (methodSig !== getCallConfigSummary.BARE_CALL) {
                const method = app.methods.find((m) => new algosdk.ABIMethod(m).getSignature() === methodSig);
                const uniqueName = methodSignatureToUniqueName[methodSig];
                yield* writer.jsDoc({
                    description: `${description} using the ${methodSig} ABI method`,
                    params: {
                        params: `Parameters for the call`,
                    },
                    returns: 'An `AppClientMethodCallParams` object for the call',
                });
                yield* factoryMethod({
                    isNested: true,
                    sanitizer,
                    name: sanitizer.makeSafeMethodIdentifier(uniqueName),
                    signature: methodSig,
                    args: method.args,
                    additionalParamTypes: `${includeCompilation ? ' & AppClientCompilationParams' : ''}${onComplete?.type ? ` & ${onComplete.type}` : ''}`,
                    contractName: name,
                });
            }
        }
        yield writer.DecIndentAndCloseBlock;
        yield writer.DecIndentAndCloseBlock;
        yield writer.NewLine;
    }
}
function* callFactoryMethod({ methodSignatureToUniqueName, callConfig, sanitizer, name }, method) {
    const methodSignature = new algosdk.ABIMethod(method).getSignature();
    if (!callConfig.callMethods.includes(methodSignature))
        return;
    yield* writer.jsDoc({
        description: `Constructs a no op call for the ${methodSignature} ABI method`,
        abiDescription: method.desc,
        params: {
            params: `Parameters for the call`,
        },
        returns: 'An `AppClientMethodCallParams` object for the call',
    });
    yield* factoryMethod({
        isNested: false,
        sanitizer,
        name: sanitizer.makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature]),
        signature: methodSignature,
        args: method.args,
        additionalParamTypes: ' & CallOnComplete',
        contractName: name,
    });
}
function* factoryMethod(m) {
    const { isNested, name, signature, args, additionalParamTypes, sanitizer, contractName } = m;
    const methodSigSafe = sanitizer.makeSafeStringTypeLiteral(signature);
    yield `${isNested ? '' : 'static '}${name}(params: CallParams<${contractName}Args['obj']['${methodSigSafe}'] | ${contractName}Args['tuple']['${methodSigSafe}']>${additionalParamTypes}): AppClientMethodCallParams${additionalParamTypes} {`;
    yield writer.IncIndent;
    yield `return {`;
    yield writer.IncIndent;
    yield '...params,';
    yield `method: '${methodSigSafe}' as const,`;
    yield `args: Array.isArray(params.args) ? params.args : [${args
        .map((a, i) => `params.args${sanitizer.getSafeMemberAccessor(sanitizer.makeSafePropertyIdentifier(a.name ?? `arg${i + 1}`))}`)
        .join(', ')}],`;
    yield writer.DecIndent;
    yield '}';
    yield writer.DecIndent;
    yield `}${isNested ? ',' : ''}`;
}

exports.paramsFactory = paramsFactory;
//# sourceMappingURL=params-factory.js.map
