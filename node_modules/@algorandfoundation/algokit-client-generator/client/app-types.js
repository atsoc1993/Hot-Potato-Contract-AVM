'use strict';

var writer = require('../output/writer.js');
var getEquivalentType = require('./helpers/get-equivalent-type.js');
var algosdk = require('algosdk');

function getMethodMetadata(method, ctx) {
    const { methodSignatureToUniqueName } = ctx;
    const methodSig = new algosdk.ABIMethod(method).getSignature();
    const uniqueName = methodSignatureToUniqueName[methodSig];
    let hasAppCallArgToTheRight = false;
    const argsMeta = new Array();
    for (let i = (method.args ?? []).length - 1; i >= 0; i--) {
        const arg = method.args[i];
        argsMeta.push({
            ...arg,
            name: arg.name ?? `arg${i + 1}`,
            isOptional: !!arg.defaultValue || (hasAppCallArgToTheRight && algosdk.abiTypeIsTransaction(arg.type)),
            tsType: getEquivalentType.getEquivalentType(arg.struct ?? arg.type, 'input', ctx),
        });
        if (!hasAppCallArgToTheRight &&
            algosdk.abiTypeIsTransaction(arg.type) &&
            [algosdk.ABITransactionType.appl, algosdk.ABITransactionType.any].includes(arg.type)) {
            hasAppCallArgToTheRight = true;
        }
    }
    argsMeta.reverse();
    return { methodSig, uniqueName, argsMeta };
}
function* appTypes(ctx) {
    yield* structTypes(ctx);
    yield* templateVariableTypes(ctx);
    const { app, name } = ctx;
    yield* writer.jsDoc(`The argument types for the ${name} contract`);
    yield `export type ${name}Args = {`;
    yield writer.IncIndent;
    yield* writer.jsDoc('The object representation of the arguments for each method');
    yield 'obj: {';
    yield writer.IncIndent;
    for (const method of app.methods) {
        const { methodSig, argsMeta } = getMethodMetadata(method, ctx);
        if (argsMeta.length) {
            yield `'${ctx.sanitizer.makeSafeStringTypeLiteral(methodSig)}': {`;
            yield writer.IncIndent;
            for (const arg of argsMeta) {
                if (arg.desc)
                    yield* writer.jsDoc(arg.desc);
                yield `${ctx.sanitizer.makeSafePropertyIdentifier(arg.name)}${arg.isOptional ? '?' : ''}: ${arg.tsType}`;
            }
            yield writer.DecIndentAndCloseBlock;
        }
        else {
            yield `'${ctx.sanitizer.makeSafeStringTypeLiteral(methodSig)}': Record<string, never>`;
        }
    }
    yield writer.DecIndentAndCloseBlock;
    yield* writer.jsDoc('The tuple representation of the arguments for each method');
    yield 'tuple: {';
    yield writer.IncIndent;
    for (const method of app.methods) {
        const { methodSig, argsMeta } = getMethodMetadata(method, ctx);
        yield* writer.inline(`'${ctx.sanitizer.makeSafeStringTypeLiteral(methodSig)}': [`, argsMeta
            .map((arg) => `${ctx.sanitizer.makeSafeVariableIdentifier(arg.name)}: ${arg.tsType}${arg.isOptional ? ' | undefined' : ''}`)
            .join(', '), ']');
    }
    yield writer.DecIndentAndCloseBlock;
    yield writer.DecIndentAndCloseBlock;
    yield writer.NewLine;
    yield* writer.jsDoc('The return type for each method');
    yield `export type ${name}Returns = {`;
    yield writer.IncIndent;
    for (const method of app.methods) {
        const { methodSig } = getMethodMetadata(method, ctx);
        yield* writer.inline(`'${ctx.sanitizer.makeSafeStringTypeLiteral(methodSig)}': ${getEquivalentType.getEquivalentType(method.returns.struct ?? method.returns.type ?? 'void', 'output', ctx)}`);
    }
    yield writer.DecIndentAndCloseBlock;
    yield writer.NewLine;
    yield* writer.jsDoc(`Defines the types of available calls and state of the ${name} smart contract.`);
    yield `export type ${name}Types = {`;
    yield writer.IncIndent;
    yield* writer.jsDoc('Maps method signatures / names to their argument and return types.');
    if (app.methods.length == 0) {
        yield 'methods: {}';
    }
    else {
        yield 'methods:';
    }
    yield writer.IncIndent;
    for (const method of app.methods) {
        const { methodSig, uniqueName } = getMethodMetadata(method, ctx);
        yield `& Record<'${ctx.sanitizer.makeSafeStringTypeLiteral(methodSig)}'${methodSig !== uniqueName ? ` | '${ctx.sanitizer.makeSafeStringTypeLiteral(uniqueName)}'` : ''}, {`;
        yield writer.IncIndent;
        yield `argsObj: ${name}Args['obj']['${ctx.sanitizer.makeSafeStringTypeLiteral(methodSig)}']`;
        yield `argsTuple: ${name}Args['tuple']['${ctx.sanitizer.makeSafeStringTypeLiteral(methodSig)}']`;
        if (method.returns.desc)
            yield* writer.jsDoc(method.returns.desc);
        yield `returns: ${name}Returns['${ctx.sanitizer.makeSafeStringTypeLiteral(methodSig)}']`;
        yield writer.DecIndent;
        yield '}>';
    }
    yield writer.DecIndent;
    const hasLocal = (app.state.keys.local && Object.keys(app.state.keys.local).length > 0) ||
        (app.state.maps.local && Object.keys(app.state.maps.local).length > 0);
    const hasGlobal = (app.state.keys.global && Object.keys(app.state.keys.global).length > 0) ||
        (app.state.maps.global && Object.keys(app.state.maps.global).length > 0);
    const hasBox = (app.state.keys.box && Object.keys(app.state.keys.box).length > 0) || (app.state.maps.box && Object.keys(app.state.maps.box).length > 0);
    yield* appState(ctx, { hasBox, hasGlobal, hasLocal });
    yield writer.DecIndentAndCloseBlock;
    yield writer.NewLine;
    yield `
  /**
   * Defines the possible abi call signatures.
   */
  export type ${name}Signatures = keyof ${name}Types['methods']
  /**
   * Defines the possible abi call signatures for methods that return a non-void value.
   */
  export type ${name}NonVoidMethodSignatures = keyof ${name}Types['methods'] extends infer T ? T extends keyof ${name}Types['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
  /**
   * Defines an object containing all relevant parameters for a single call to the contract.
   */
  export type CallParams<TArgs> = Expand<
    Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
      {
        /** The args for the ABI method call, either as an ordered array or an object */
        args: Expand<TArgs>
      }
  >
  /**
   * Maps a method signature from the ${name} smart contract to the method's arguments in either tuple or struct form
   */
  export type MethodArgs<TSignature extends ${name}Signatures> = ${name}Types['methods'][TSignature]['argsObj' | 'argsTuple']
  /**
   * Maps a method signature from the ${name} smart contract to the method's return type
   */
  export type MethodReturn<TSignature extends ${name}Signatures> = ${name}Types['methods'][TSignature]['returns']
  `;
    if (hasGlobal) {
        yield `
      /**
       * Defines the shape of the keyed global state of the application.
       */
      export type GlobalKeysState = ${name}Types['state']['global']['keys']
    `;
    }
    if (hasLocal) {
        yield `
      /**
       * Defines the shape of the keyed local state of the application.
       */
      export type LocalKeysState = ${name}Types['state']['local']['keys']
    `;
    }
    if (hasBox) {
        yield `
      /**
       * Defines the shape of the keyed box state of the application.
       */
      export type BoxKeysState = ${name}Types['state']['box']['keys']
    `;
    }
    yield writer.NewLine;
}
/* eslint-disable @typescript-eslint/no-explicit-any */
function getStructAsObject(struct, ctx) {
    return Object.fromEntries(struct.map((s) => [s.name, typeof s.type === 'string' ? getEquivalentType.getEquivalentType(s.type, 'output', ctx) : getStructAsObject(s.type, ctx)]));
}
function getStructAsTupleTypes(struct, ctx) {
    return `[${struct.map((s) => {
        return Array.isArray(s.type) ? getStructAsTupleTypes(s.type, ctx) : Object.keys(ctx.app.structs).includes(s.type) ? getStructAsTupleTypes(ctx.app.structs[s.type], ctx) : getEquivalentType.getEquivalentType(s.type, "output", ctx);
    }).join(', ')}]`;
}
function* structTypes(ctx) {
    const { app, sanitizer } = ctx;
    if (Object.keys(app.structs).length === 0)
        return;
    yield '// Type definitions for ARC-56 structs';
    yield writer.NewLine;
    for (const structName of Object.keys(app.structs)) {
        // Emit the struct type
        yield `export type ${sanitizer.makeSafeTypeIdentifier(structName)} = ${JSON.stringify(getStructAsObject(app.structs[structName], ctx), null, 2).replace(/"/g, '')}`;
        yield writer.NewLine;
        // Emit method that converts ABI tuple to the struct object
        yield* writer.jsDoc(`Converts the ABI tuple representation of a ${structName} to the struct representation`);
        yield* writer.inline(`export function ${sanitizer.makeSafeTypeIdentifier(structName)}FromTuple(`, `abiTuple: ${getStructAsTupleTypes(app.structs[structName], ctx)}`, `) {`);
        yield* writer.indent(`return getABIStructFromABITuple(abiTuple, APP_SPEC.structs${sanitizer.getSafeMemberAccessor(structName)}, APP_SPEC.structs) as ${sanitizer.makeSafeTypeIdentifier(structName)}`);
        yield '}';
        yield writer.NewLine;
    }
}
function* templateVariableTypes(ctx) {
    if (Object.keys(ctx.app.templateVariables ?? {}).length === 0) {
        return;
    }
    yield* writer.jsDoc('Deploy-time template variables');
    yield 'export type TemplateVariables = {';
    yield writer.IncIndent;
    for (const name of Object.keys(ctx.app.templateVariables ?? {})) {
        yield `${name}: ${getEquivalentType.getEquivalentType(ctx.app.templateVariables[name].type, 'output', ctx)},`;
    }
    yield writer.DecIndentAndCloseBlock;
    yield writer.NewLine;
}
function* keysAndMaps(app, sanitizer, keys, maps) {
    if (keys && Object.keys(keys).length) {
        yield 'keys: {';
        yield writer.IncIndent;
        for (const name of Object.keys(keys)) {
            const prop = keys[name];
            if (prop.desc) {
                yield* writer.jsDoc(prop.desc);
            }
            const keySafe = sanitizer.makeSafePropertyIdentifier(name);
            yield `${keySafe}: ${prop.valueType === 'AVMBytes' ? 'BinaryState' : getEquivalentType.getEquivalentType(prop.valueType, 'output', { app, sanitizer })}`;
        }
        yield writer.DecIndentAndCloseBlock;
    }
    else {
        yield 'keys: {}';
    }
    if (maps && Object.keys(maps).length) {
        yield 'maps: {';
        yield writer.IncIndent;
        for (const name of Object.keys(maps)) {
            const prop = maps[name];
            if (prop.desc) {
                yield* writer.jsDoc(prop.desc);
            }
            const keySafe = sanitizer.makeSafePropertyIdentifier(name);
            yield `${keySafe}: Map<${getEquivalentType.getEquivalentType(prop.keyType, 'input', { app, sanitizer })}, ${getEquivalentType.getEquivalentType(prop.valueType, 'output', { app, sanitizer })}>`;
        }
        yield writer.DecIndentAndCloseBlock;
    }
    else {
        yield 'maps: {}';
    }
}
function* appState({ app, sanitizer }, stateFlags) {
    const { hasBox, hasGlobal, hasLocal } = stateFlags;
    if (hasLocal || hasGlobal || hasBox) {
        yield* writer.jsDoc('Defines the shape of the state of the application.');
        yield 'state: {';
        yield writer.IncIndent;
        if (hasGlobal) {
            yield 'global: {';
            yield writer.IncIndent;
            yield* keysAndMaps(app, sanitizer, app.state.keys.global, app.state.maps.global);
            yield writer.DecIndentAndCloseBlock;
        }
        if (hasLocal) {
            yield 'local: {';
            yield writer.IncIndent;
            yield* keysAndMaps(app, sanitizer, app.state.keys.local, app.state.maps.local);
            yield writer.DecIndentAndCloseBlock;
        }
        if (hasBox) {
            yield 'box: {';
            yield writer.IncIndent;
            yield* keysAndMaps(app, sanitizer, app.state.keys.box, app.state.maps.box);
            yield writer.DecIndentAndCloseBlock;
        }
        yield writer.DecIndentAndCloseBlock;
    }
}

exports.appTypes = appTypes;
//# sourceMappingURL=app-types.js.map
