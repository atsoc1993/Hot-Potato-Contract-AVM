'use strict';

var writer = require('../output/writer.js');
var getCallConfigSummary = require('./helpers/get-call-config-summary.js');
var algosdk = require('algosdk');

function getCreateOnCompleteOptions(method, app) {
    const validCreateOnCompletes = method === getCallConfigSummary.BARE_CALL ? app.bareActions.create : app.methods.find((m) => new algosdk.ABIMethod(m).getSignature() === method)?.actions?.create;
    const hasNoOp = validCreateOnCompletes?.includes('NoOp');
    const onCompleteType = validCreateOnCompletes
        ? `{onComplete${hasNoOp ? '?' : ''}: ${validCreateOnCompletes.map((oc) => `OnApplicationComplete.${oc}OC`).join(' | ')}}`
        : {};
    return {
        type: onCompleteType,
        isOptional: hasNoOp,
    };
}
function getCallOnCompleteOptions(method, app) {
    const validCallOnCompletes = method === getCallConfigSummary.BARE_CALL ? app.bareActions.call : app.methods.find((m) => new algosdk.ABIMethod(m).getSignature() === method)?.actions?.call;
    const hasNoOp = validCallOnCompletes?.includes('NoOp');
    const onCompleteType = validCallOnCompletes
        ? `{onComplete${hasNoOp ? '?' : ''}: ${validCallOnCompletes.map((oc) => `OnApplicationComplete.${oc}OC`).join(' | ')}}`
        : {};
    return {
        type: onCompleteType,
        isOptional: hasNoOp,
    };
}
function* deployTypes({ app, callConfig, sanitizer, methodSignatureToUniqueName }) {
    const name = sanitizer.makeSafeTypeIdentifier(app.name);
    if (callConfig.createMethods.length > 0) {
        yield* writer.jsDoc('Defines supported create method params for this smart contract');
        yield `export type ${name}CreateCallParams =`;
        yield writer.IncIndent;
        for (const method of callConfig.createMethods) {
            const onComplete = getCreateOnCompleteOptions(method, app);
            if (method === getCallConfigSummary.BARE_CALL) {
                yield `| Expand<AppClientBareCallParams & {method?: never} & ${onComplete.type} & CreateSchema>`;
            }
            else {
                const methodSigSafe = sanitizer.makeSafeStringTypeLiteral(method);
                const uniqueName = methodSignatureToUniqueName[method];
                if (uniqueName !== method) {
                    const methodName = sanitizer.makeSafeStringTypeLiteral(uniqueName);
                    yield `| Expand<CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']> & {method: '${methodName}'} & ${onComplete.type} & CreateSchema>`;
                }
                yield `| Expand<CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']> & {method: '${methodSigSafe}'} & ${onComplete.type} & CreateSchema>`;
            }
        }
        yield writer.DecIndent;
    }
    if (callConfig.updateMethods.length > 0) {
        yield* writer.jsDoc('Defines supported update method params for this smart contract');
        yield `export type ${name}UpdateCallParams =`;
        yield writer.IncIndent;
        for (const method of callConfig.updateMethods) {
            if (method === getCallConfigSummary.BARE_CALL) {
                yield `| Expand<AppClientBareCallParams> & {method?: never}`;
            }
            else {
                const uniqueName = methodSignatureToUniqueName[method];
                const methodSigSafe = sanitizer.makeSafeStringTypeLiteral(method);
                if (uniqueName !== method) {
                    const methodName = sanitizer.makeSafeStringTypeLiteral(uniqueName);
                    yield `| Expand<CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']> & {method: '${methodName}'}>`;
                }
                yield `| Expand<CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']> & {method: '${methodSigSafe}'}>`;
            }
        }
        yield writer.DecIndent;
    }
    if (callConfig.deleteMethods.length > 0) {
        yield* writer.jsDoc('Defines supported delete method params for this smart contract');
        yield `export type ${name}DeleteCallParams =`;
        yield writer.IncIndent;
        for (const method of callConfig.deleteMethods) {
            if (method === getCallConfigSummary.BARE_CALL) {
                yield `| Expand<AppClientBareCallParams> & {method?: never}`;
            }
            else {
                const uniqueName = methodSignatureToUniqueName[method];
                const methodSigSafe = sanitizer.makeSafeStringTypeLiteral(method);
                if (uniqueName !== method) {
                    const methodName = sanitizer.makeSafeStringTypeLiteral(uniqueName);
                    yield `| Expand<CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']> & {method: '${methodName}'}>`;
                }
                yield `| Expand<CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']> & {method: '${methodSigSafe}'}>`;
            }
        }
        yield writer.DecIndent;
    }
    yield* writer.jsDoc('Defines arguments required for the deploy method.');
    yield `export type ${name}DeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {`;
    yield writer.IncIndent;
    if (callConfig.createMethods.length) {
        yield* writer.jsDoc('Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)');
        yield `createParams?: ${name}CreateCallParams`;
    }
    if (callConfig.updateMethods.length) {
        yield* writer.jsDoc('Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)');
        yield `updateParams?: ${name}UpdateCallParams`;
    }
    if (callConfig.deleteMethods.length) {
        yield* writer.jsDoc('Delete transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)');
        yield `deleteParams?: ${name}DeleteCallParams`;
    }
    yield writer.DecIndent;
    yield `}>`;
    yield writer.NewLine;
}

exports.deployTypes = deployTypes;
exports.getCallOnCompleteOptions = getCallOnCompleteOptions;
exports.getCreateOnCompleteOptions = getCreateOnCompleteOptions;
//# sourceMappingURL=deploy-types.js.map
